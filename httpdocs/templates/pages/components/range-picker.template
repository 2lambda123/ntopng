{#
    (C) 2021 - ntop.org    
#}

{%
    -- if there are set the _GET["epoch_begin"] && _GET["epoch_end"]
    -- then select the `Custom` Label 
    local presetSelected = (isEmptyString(_GET["epoch_begin"]) and isEmptyString(_GET["epoch_end"]))
%}

<link rel="stylesheet" href="{{ ntop.getHttpPrefix }}/css/tagify.css" />
<style>
.tagify__input {
  min-width: 175px;
}
.tagify__tag {
  white-space: nowrap;
  margin: 3px 0px 5px 5px;
}
.tagify__tag select.operator {
  margin: 0px 4px;
  border: 1px solid #c4c4c4;
  border-radius: 4px;
}
.tagify__tag b.operator {
  margin: 0px 4px;
  background-color: white;
  border: 1px solid #c4c4c4;
  border-radius: 4px;
  padding: 0.05em 0.2em;
}
.tagify__tag > div {
  display: flex;
  align-items: center;
}
</style>

<div class="w-100">

    <div class="range-container d-flex flex-wrap">
    
        {% if not isEmptyString(extra_range_buttons) then %}
            {* extra_range_buttons *}
        {% end %}

        <div class="range-picker d-flex my-auto flex-wrap">

            {% if query_presets ~= nil and query_presets ~= {} then %}
            <div class="form-group my-auto mx-1">
                <select class="form-select" id="select-query-presets">
                {% if query_presets_subtype == "tables" then %}
                    <option value="">{{ i18n('queries.raw_flows') }}</option>
                    <optgroup label="{{ i18n('queries.queries') }}">
                    {% end %}
                       {% for id, preset in pairsByKeys(query_presets) do %}
                        <option {{ preset.selected and 'selected' }} value="{{ id }}">{{ preset.i18n_name and i18n(preset.i18n_name) or preset.name }}</option>      
                        {% end %}
                    {% if query_presets_subtype == "tables" then %}
                    </optgroup>
                {% end %}
                </select>
            </div>   
            {% end %}

            <div class="form-group my-auto mx-1">
                <select class="form-select" id="select-time-presets">
                    {% if (presets.five_mins) or (presets.five_mins ~= false) then %}
                    <option {{ ((presetSelected and default == '5min') and 'selected' or '') }} value="5,minutes">{{ i18n('show_alerts.presets.5_min') }}</option>
                    {% end  %}
                    
                    <option {{ ((presetSelected and default == '30min') and 'selected' or '') }} value="30,minutes">{{ i18n('show_alerts.presets.30_min') }}</option>
                    
                    <option {{ ((presetSelected and default == '1hour') and 'selected' or '') }} value="1,hours">{{ i18n('show_alerts.presets.hour') }}</option>
                    
                    {% if (presets.day == nil) or presets.day then %}
                    <option {{ ((presetSelected and default == '1day') and 'selected' or '') }} value="1,days">{{ i18n('show_alerts.presets.day') }}</option>
                    {% end  %}
                    
                    {% if (presets.week == nil) or presets.week then %}
                    <option {{ ((presetSelected and default == '1week') and 'selected' or '') }} value="1,weeks">{{ i18n('show_alerts.presets.week') }}</option>
                    {% end  %}
                    
                    {% if (presets.month == nil) or presets.month then %}
                    <option value="1,months">{{ i18n('show_alerts.presets.month') }}</option>
                    {% end  %}
                    
                    {% if (presets.year == nil) or presets.year then %}
                    <option value="1,years">{{ i18n('show_alerts.presets.year') }}</option>
                    {% end  %}

                    <option {{ ((presetSelected and default == 'all') and 'selected' or '') }} value="{{ (earliest_available_epoch or 0) }}">{{ i18n('show_alerts.presets.all') }}</option>
                    
                    <option value="custom" disabled {{ not presetSelected and 'selected' or '' }}>{{ i18n("graphs.custom") }}</option>
                </select>
            </div>

            <div style="width: 33rem;" class="input-group mx-1">
                <span class="input-group-text">
                    <i class="fas fa-calendar-alt"></i>
                </span>
                <input id="begin-date" type="date" class="begin-timepicker form-control border-right-0 fix-safari-input">
                <input id="begin-time" type="time" class="begin-timepicker form-control border-right-0 fix-safari-input">
                <span class="input-group-text">
                        <i class="fas fa-long-arrow-alt-right"></i>
                    </span>
                <input id="end-date" type="date" class="end-timepicker form-control border-left-0 fix-safari-input">
                <input id="end-time" type="time" class="end-timepicker form-control border-left-0 fix-safari-input">
            </div>

            <span class="wrong-ranger invalid-feedback mx-1 my-auto" data-bs-toggle="tooltip" data-placement="bottom" title="{{ i18n('wrong_date_range') }}" style="width: 1rem; display: none;">
                <i class="fas fa-exclamation-circle"></i>
            </span>

    
            <div class="controls d-flex flex-wrap">
                <div class="btn-group me-auto btn-group-sm">
                    <button class="btn btn-link" id="btn-jump-time-back">
                        <i class="fas fa-long-arrow-alt-left"></i>
                    </button>
                    <button class="btn btn-link me-2" disabled id="btn-jump-time-ahead">
                        <i class="fas fa-long-arrow-alt-right"></i>
                    </button>
                    <button class="btn btn-link" id="btn-zoom-in">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="btn btn-link" id="btn-zoom-out">
                        <i class="fas fa-search-minus"></i>
                    </button>
                </div>
            </div>
        </div>
    
        <button id="btn-apply" class="btn btn-sm btn-primary m-auto ms-1">{{ i18n("apply") }}</button>
    {% if (show_jump) then %}
        <div class="form-group my-auto mx-1">
            <a href="{{ jump_endpoint }}" class="btn btn-sm btn-primary ms-auto" id="jumpButton"><i class="fas fa-filter"></i> {{ show_jump_text or i18n("jump_to_table") }}</a>
        </div>
    {% end %}

    {% if (show_auto_refresh) then %}
        <div class="form-group my-auto mx-1">
            <button class="btn btn-link" id="autoRefreshEnabled" style="box-shadow: none;"><i class="fas fa-sync-alt {{ refresh_enabled }}"></i></button>
        </div>
    {% end %}
    </div>
    

    {% if tags.enabled then %}
    <div class="d-flex mt-1">
    {% else %}
    <div class="d-none mt-1">
    {% end %}

        <input class="w-100 form-control h-auto" name="tags" placeholder="{{ i18n('show_alerts.filters') }}">

        {% if not isEmptyString(extra_tags_buttons) then %}
            {* extra_tags_buttons *}
        {% end %}
        
        <button data-bs-toggle="tooltip" data-placement="bottom" title="{{ i18n('show_alerts.remove_filters') }}" class="btn ms-1 my-auto btn-sm btn-remove-tags">
            <i class="fas fa-times"></i>
        </button>
    </div>

</div>
  

<script type="text/javascript" src="{{ ntop.getHttpPrefix }}/js/tagify.min.js"></script>
<script type="text/javascript">

/* Tags definitions */
i18n.tags = {* json.encode(tags.localization) *};
const TAG_OPERATORS = {* json.encode(tags.tag_operators) *};
const DEFINED_TAGS = {* json.encode(tags.defined_tags) *};
const VIEW_ONLY_TAGS = {* tags.view_only *};

/* Initial Tags */
const initialTags =  {* json.encode(tags.values) *};

/* Parameters */
let beginEpoch = {{ (epoch_begin or _GET['epoch_begin'] or 'undefined') }};
let endEpoch = {{ (epoch_end or _GET['epoch_end'] or 'undefined') }};
const datasourceParams = {* json.encode(datasource_params) *};
const currentDate = new Date();

/*  If defined, use the standard Date, the Date constructor 
    needs a unix timestamp * 1000 to get the right date */
if(beginEpoch) beginEpoch = new Date(beginEpoch * 1000);
if(endEpoch) endEpoch = new Date(endEpoch * 1000);

let pageHandle = {};

const inputTags = $(`[name='tags']`)[0];
const $inputBeginEpoch = $(`.begin-timepicker`);
const $inputEndEpoch = $(`.end-timepicker`);

/* Reset values - some browsers keep the value on reload (e.g. Firefox) */
inputTags.value = "";
$inputBeginEpoch.value = "";
$inputEndEpoch.value = "";

{% if query_presets ~= nil and query_presets ~= {} then %}
let currentQueryPresets = $(`#select-query-presets`).val();
{% end %}

const tagify = new Tagify(inputTags, {
    duplicates: true,
    delimiters : null,
    dropdown : {
        enabled: 1, // suggest tags after a single character input
        classname : 'extra-properties' // custom class for the suggestions dropdown
    },
    autoComplete: { enabled: false },
    templates : {
        tag : function(tagData){
            try{
                return `<tag title='${tagData.value}' contenteditable='false' spellcheck="false" class='tagify__tag ${tagData.class ? tagData.class : ""}' ${this.getAttributes(tagData)}>
                        <x title='remove tag' class='tagify__tag__removeBtn'></x>
                        <div>
                            ${tagData.label ? `<b>${tagData.label}</b>&nbsp;` : ``}
                            ${!VIEW_ONLY_TAGS && tagData.operators ? `<select class='operator'>${tagData.operators.map(op => `<option ${tagData.selectedOperator === op ? 'selected' : ''} value='${op}'>${TAG_OPERATORS[op]}</option>`).join()}</select>` : `<b class='operator'>${tagData.selectedOperator ? TAG_OPERATORS[tagData.selectedOperator] : '='}</b>`}&nbsp;
                            <span class='tagify__tag-text'>${tagData.value}</span>
                        </div>
                    </tag>`
            }
            catch(err){
                console.error(`An error occured when creating a new tag: ${err}`);
            }
        },
    },
    validate: function(tagData) {
       return (typeof tagData.key !== 'undefined' &&
               typeof tagData.selectedOperator !== 'undefined' &&
               typeof tagData.value !== 'undefined');
    }
});

$(document).ready(function() {
    // add existing tags
    tagify.addTags(initialTags);

    // intialize tooltip
    $(`.btn-remove-tags`).tooltip();

    const rangepickerEvent = new Event('change');

    const MAX_ZOOM_IN = {{ (max_delta_in) }}; // 5 minutes
    const MAX_ZOOM_OUT = {{ (max_delta_out) }}; // 12 hours
    
    let now = (endEpoch === undefined) ? currentDate : endEpoch;
    
    const last30Min = new Date(now - (60000 * 30)); // Get Timestamp of the last 30 min in case no other beginEpoch is given
    let prev = (beginEpoch === undefined) ? last30Min : beginEpoch;

    const $rangePicker = $(`.range-picker`)[0];

    const $btnApply = $(`#btn-apply`);
    const $btnJumpTimeBack = $(`#btn-jump-time-back`);
    const $btnJumpTimeAhead = $(`#btn-jump-time-ahead`);
    const $btnZoomIn = $(`#btn-zoom-in`);
    const $btnZoomOut = $(`#btn-zoom-out`);

    const $selectTimePresets = $(`#select-time-presets`);

    function calculateHalfZoomIn() {
        const begin = new Date($(`#begin-date`).val() + "T" + $(`#begin-time`).val() + "Z");
        const end = new Date($(`#end-date`).val() + "T" + $(`#end-time`).val() + "Z");

        const delta = end.getTime() - begin.getTime();
        const zoomIn = delta / 3;
        const halfZoomIn = (zoomIn) / 2;
        return [begin, end, delta, halfZoomIn];
    }

    function highlightCustomPresetButton() {
        $(`#select-time-presets`).val('custom');
    }

    function disableRangePickerButtons() {
        $('.controls button').attr('disabled', 'disabled');
    }

    function enableRangePickerButtons() {
        $('.controls button').removeAttr('disabled');
    }

    function highlightWrongDate() {
        $(`.range-picker .input-group`).addClass('border').addClass('rounded').addClass('border-danger');
        $(`.wrong-ranger`).show();
    }

    function disableWrongDate() {
        $(`.range-picker .input-group`).removeClass('border').removeClass('rounded').removeClass('border-danger');
        $(`.wrong-ranger`).hide();
    }

    function updateRangePicker(operation, maxDate) {

        // get the selected preset or the first preset available
        const [delta, measure] = ($selectTimePresets.val() || $(`#select-time-presets option:first`).val()).split(',');
        let begin = newDate($(`#begin-date`).val() + "T" + $(`#begin-time`).val() + "Z")
        let end = newDate($(`#end-date`).val() + "T" + $(`#end-time`).val() + "Z")
        
        end = moment(begin.getTime() / 1000);
        begin = moment(begin.getTime() / 1000);
        
        begin = new Date(begin[operation](parseInt(delta), measure).unix() * 1000).toISOString().slice(0,16);
        end = new Date(end[operation](parseInt(delta), measure).unix() * 1000).toISOString().slice(0,16);

        /* TODO: remove moment.js library dependence */
        end = end.split('T');
        begin = begin.split('T');

        $(`#end-date`).attr('min', begin[0]);
        $(`#begin-date`).attr('max', end[0]);

        $(`#begin-date`).attr('value', begin[0]);
        $(`#begin-time`).attr('value', begin[1]);
        
        $(`#end-date`).attr('value', end[0]);
        $(`#end-time`).attr('value', end[1]);

        // if the new end time is less than the max current date then
        // enable the jump time ahead button, otherwise disable it
        if (end < maxDate) {
            $btnJumpTimeAhead.removeClass('disabled');
        }
        else {
            $btnJumpTimeAhead.addClass('disabled');
        }

        $rangePicker.dispatchEvent(rangepickerEvent);
    }

    $('[data-bs-toggle="tooltip"]').tooltip();
    
    if(prev.getTime() > now.getTime()) {
        disableRangePickerButtons();
        highlightWrongDate();
    } else {
        enableRangePickerButtons();
        disableWrongDate();
    }

    // initialize timepickers
    // slice the ISO String to match input date time value format
    now = now.toISOString().slice(0,16).split('T');
    prev = prev.toISOString().slice(0,16).split('T');

    $(`#end-date`).attr('min', prev[0]);
    $(`#begin-date`).attr('max', now[0]);

    $(`#begin-date`).attr('value', prev[0]);
    $(`#begin-time`).attr('value', prev[1]);
    
    $(`#end-date`).attr('value', now[0]);
    $(`#end-time`).attr('value', now[1]);

    $selectTimePresets.on('change', function(e) {

        // remove the active class
        const [subtract, measure] = $(this).val().split(',');
        let now = new Date();
        let diff;

        if(!measure)
            diff = new Date(now.getTime() - (subtract * 1000));
        else /* TODO: remove the dependence from the moment.js library and use just standard Date library */
            diff = new Date((moment().subtract(parseInt(subtract), measure).unix()) * 1000);

        diff = diff.toISOString().slice(0,16).split('T');
        now = now.toISOString().slice(0,16).split('T');

        $(`#end-date`).attr('min', diff[0]);
        $(`#begin-date`).attr('max', now[0]);

        $(`#begin-date`).attr('value', diff[0]);
        $(`#begin-time`).attr('value', diff[1]);
        
        $(`#end-date`).attr('value', now[0]);
        $(`#end-time`).attr('value', now[1]);

        enableRangePickerButtons();
        disableWrongDate();
    });

    // travel back in the past by the selected preset
    $btnJumpTimeBack.on('click', () => {updateRangePicker('subtract', now)});
    // travel ahead in the future by the selected preset
    $btnJumpTimeAhead.on('click', () => {updateRangePicker('add', now)});

    $btnZoomIn.on('click', function() {

        const [begin, end, delta, halfZoomIn] = calculateHalfZoomIn();

        let newBegin = new Date(begin.getTime() + halfZoomIn);
        let newEnd = new Date(end.getTime() + halfZoomIn);

        newBegin = newBegin.toISOString().slice(0,16).split('T');
        newEnd = newEnd.toISOString().slice(0,16).split('T');
        
        $(`#begin-date`).attr('value', newBegin[0]);
        $(`#begin-time`).attr('value', newBegin[1]);
        
        $(`#end-date`).attr('value', newEnd[0]);
        $(`#end-time`).attr('value', newEnd[1]);
        
        // if delta is lower than 5 minutes then disable the zoom in button
        if (delta < MAX_ZOOM_IN) {
            $(this).attr("disabled", "disabled");
        }

        $btnZoomOut.removeAttr("disabled");
        $rangePicker.dispatchEvent(rangepickerEvent);
    });

    $btnZoomOut.on('click', function() {

        const [begin, end, delta, halfZoomIn] = calculateHalfZoomIn();

        let newBegin = new Date(begin.getTime() - (halfZoomIn * 1000));
        let newEnd = new Date(end.getTime() - (halfZoomIn * 1000));
        
        newBegin = newBegin.toISOString().slice(0,16).split('T');
        newEnd = newEnd.toISOString().slice(0,16).split('T');
        
        $(`#begin-date`).attr('value', newBegin[0]);
        $(`#begin-time`).attr('value', newBegin[1]);
        
        $(`#end-date`).attr('value', newEnd[0]);
        $(`#end-time`).attr('value', newEnd[1]);

        // if delta is lower than 5 minutes then disable the zoom in button
        if (delta > MAX_ZOOM_OUT) {
            $(this).attr("disabled", "disabled");
        }

        $btnZoomIn.removeAttr("disabled");
        $rangePicker.dispatchEvent(rangepickerEvent);
    });

	/* Autoselect the 'custom' dropdown entry when clicking any of the buttons */
	$.each([$btnApply, $btnJumpTimeBack, $btnJumpTimeAhead], function(idx, btn) {
	    $(btn).on('click', function() {
		highlightCustomPresetButton();
		$rangePicker.dispatchEvent(rangepickerEvent);
        });
	});

    /* Change the end epoch minimum */
    $inputBeginEpoch.on("change", function (e) {
        const newBegin = new Date($(`#begin-date`).val() + "T" + $(`#begin-time`).val() + "Z");
        const end = new Date($(`#end-date`).val() + "T" + $(`#end-time`).val() + "Z");

        // Set up the minimum end date to the current begin date
        $(`#end-date`).attr('min', $(`#begin-date`).val());
        
        if(newBegin == "Invalid Date" || end == "Invalid Date" || (newBegin.getTime() > end.getTime())) {
            disableRangePickerButtons();
            highlightWrongDate();
        } else {
            enableRangePickerButtons();
            disableWrongDate();
        }
    });

    $inputEndEpoch.on("change", function (e) {
        const newEnd = new Date($(`#end-date`).val() + "T" + $(`#end-time`).val() + "Z");
        const begin = new Date($(`#begin-date`).val() + "T" + $(`#begin-time`).val() + "Z");

        // Set up the minimum end date to the current begin date
        $(`#begin-date`).attr('max', $(`#end-date`).val());
        
        if(begin == "Invalid Date" || newEnd == "Invalid Date" || (begin.getTime() > newEnd.getTime())) {
            disableRangePickerButtons();
            highlightWrongDate();
        } else {
            enableRangePickerButtons();
            disableWrongDate();
        }
    });
}); /* $(document).ready() */


/* Global range picker functions */
    function getTimestampRange(updateDatetimeUsingPresets = false) {
        let begin;
        let end;
        const selectTimePresets = $(`#select-time-presets`).val();
            
        if(updateDatetimeUsingPresets && selectTimePresets) {
            // getting the current time using presets
            const [subtract, measure] = selectTimePresets.split(',');
            const now = new Date();
            let diff = new Date(moment().subtract(parseInt(subtract), measure).unix() * 1000);

            begin = diff;
            end = now;

            /* TODO: remove moment.js library */
            if(!measure)
                diff = new Date(moment(parseInt(subtract)).unix() * 1000);

            diff = diff.toISOString().slice(0,16).split('T');
            now = now.toISOString().slice(0,16).split('T');
            
            // update the datetimepickers and their maximum / minimum value
            $(`#end-date`).attr('min', diff[0]);
            $(`#begin-date`).attr('max', now[0]);

            $(`#begin-date`).attr('value', diff[0]);
            $(`#begin-time`).attr('value', diff[1]);
            
            $(`#end-date`).attr('value', now[0]);
            $(`#end-time`).attr('value', now[1]);
        } else {
            if($(`#begin-date`).val() && $(`#begin-time`).val()) /* the html input tag is defined */
                begin = new Date($(`#begin-date`).val() + "T" + $(`#begin-time`).val() + "Z");
            else /* the html input tag is still not loaded */
                begin = new Date(Number(datasourceParams.epoch_begin) * 1000);   

            if($(`#end-date`).val() && $(`#end-time`).val()) /* the html input tag is defined */
                end = new Date($(`#end-date`).val() + "T" + $(`#end-time`).val() + "Z");
            else
                end = new Date(Number(datasourceParams.epoch_end) * 1000);
        }

        /* return the values in timestamp unix format */
        return [Math.trunc(Number(begin.getTime() / 1000)), Math.trunc(Number(end.getTime() / 1000))];
    }

    function getSearchParams() {
        const searchParams = new URLSearchParams();

        // get all filters tags
        const tags = tagify.getTagElms();

        // add the tag filters inside the search params object
        for (const tag of tags) {
            const tagData = tagify.tagData(tag);

            const key = tagData.key;
            const selectedOperator = tagData.selectedOperator;
            const realValue = tagData.realValue;
            const value = tagData.value;

            let param_value = `${realValue || value}{{ opsep }}${selectedOperator || 'eq'}`;
            if (searchParams.get(key)) {
                param_value = `${searchParams.get(key)},${param_value}`;
            }

            searchParams.set(key, param_value);
        }

        {% if query_presets ~= nil and query_presets ~= {} then %}
        // add selected query preset
        searchParams.set('query_preset', $(`#select-query-presets`).val());
        {% end %}

        return searchParams;
    }

    function setDatasourceParams() {
        const searchParams = getSearchParams();
        let changedTime = false;

        searchParams.forEach(function(value, key) {
            datasourceParams[key] = value;
        });

        let [begin, end] = getTimestampRange();
        
        if (begin == null && end == null) return datasourceParams, changedTime;
        if (datasourceParams.epoch_begin != begin || datasourceParams.epoch_end != end) changedTime = true;
        // override the existing timestamps 
        if (datasourceParams.epoch_begin) datasourceParams.epoch_begin = begin; 
        if (datasourceParams.epoch_end  ) datasourceParams.epoch_end   = end;

        return datasourceParams, changedTime;
    }

    function updateNavbarLink(url, begin, end, element) {
        const searchParams = getSearchParams();

        searchParams.set('epoch_begin', begin);
        searchParams.set('epoch_end', end);
        
        if (url.searchParams.has('status')) {
            searchParams.set('status', url.searchParams.get('status'));
        }

        /* Read the current href */
        const cur_href = $(element).attr('href');
        let cur_url = new URL(cur_href, location.origin);
        /* Read current href params and extract the page name */
        const cur_page = cur_url.searchParams.get('page');
        if(cur_page) {
            /* Prepare the new URL which is the page name extracted plus all other params */
            searchParams.set('page', cur_page);
            searchParams.delete('alert_id');
            cur_url.search = searchParams.toString();
            /* Attach the new URL to the current href */
            $(element).attr('href', cur_url.toString());
        }
    }

    function updateStatusSwitchLink(begin, end, element) {
        const cur_href = $(element).attr('href');
        let cur_url = new URL(cur_href, location.origin + location.pathname);
        let searchParams = new URLSearchParams(cur_url.search);

        /* Set updated epoch */
        searchParams.set('epoch_begin', begin);
        searchParams.set('epoch_end',   end);

        /* Attach the new URL to the current href */
        cur_url.search = searchParams.toString();
        $(element).attr('href', cur_url.toString());
    }

    function pushNewHistoryState(begin, end, len, dontUpdateNavBar, changedTime) {
        const url = new URL(location);
        const searchParams = getSearchParams();
        searchParams.set('epoch_begin', begin);
        searchParams.set('epoch_end', end);

        if (url.searchParams.has('status')) {
            searchParams.set('status', url.searchParams.get('status'));
        }

        /*
          Update navbar items, e.g., alert entities, with begin/end epochs
          and status to preserve them when switching between tabs
         */
        if(dontUpdateNavBar == undefined || dontUpdateNavBar == false) {
            $('#navbarNav a').each(function(index, element) {
                updateNavbarLink(url, begin, end, element);
            });
        }

        /*
          Update status switch items (Engaged, Acknoledged, Past)
          with begin/end epochs to preserve them when switching status
         */
        $('#statusSwitch a').each(function(index, element) {
            updateStatusSwitchLink(begin, end, element);
        });

        /*
          Other page params are not preserved when switching tabs as they may be not valid across
          multiple entities
         */
        searchParams.delete('page');
        if (url.searchParams.has('page')) {
            searchParams.set('page', url.searchParams.get('page'));
        }

        url.search = searchParams.toString();
        window.history.pushState({epoch_begin: begin, epoch_end: end}, '', url);

        if (changedTime === true && !{{ dont_refresh_full_page or false }}) {
            window.location.reload();
        }

        if (document.getElementById("jumpButton")) {
            $('#jumpButton').each(function(index, element) {
                updateNavbarLink(url, begin, end, element);
            });
        }
    }

    async function onRangePickerChange(pushHistroy = false, updateDatetimeUsingPresets = false) {
        const [begin, end] = getTimestampRange(updateDatetimeUsingPresets);
        let changedTime = false;
        datasourceParams, changedTime = setDatasourceParams();
        
	{% if query_presets ~= nil and query_presets ~= {} then %}
	if (currentQueryPresets != $(`#select-query-presets`).val()) {
	    pushNewHistoryState(begin, end);
	    /* Reload the page to change datatable columns */
        location.reload();
	    return;
	}
	{% end %}
        if (pushHistroy) {
            pushNewHistoryState(begin, end, null, {{ dont_update_navbar or 'false' }}, changedTime);
        }
        /* The reloadTable callback should be defined by the page (e.g. datatable.template) 
         * to update the content on range or filters update (TODO define a cleaner API for this) */
        if (typeof $table !== 'undefined') {
            await reloadTable($table, begin, end);
        }
    }

    async function addFilterTag(tag) {
        /* Convert values to string (this avoids issues e.g. with 0) */
        if (typeof tag.realValue == 'number') { tag.realValue = ''+tag.realValue; }
        if (typeof tag.value == 'number') { tag.value = ''+tag.value; }

        const existingTagElms = tagify.getTagElms();
        
        /* Lookup by index (allow key dup, replace the value only if it's the same element index or same key and op) */
        if (tag.index && existingTagElms.length > tag.index) {
            let existingTagElement = existingTagElms[tag.index] || existingTagElms.find(htmlTag => htmlTag.getAttribute('key') === tag.key && htmlTag.getAttribute('selectedOperator') === tag.selectedOperator);
            if (existingTagElement) {
                let existingTag = tagify.tagData(existingTagElement);

                // replace the tag!
                existingTag.value = tag.value;
                existingTag.realValue = tag.realValue;
                if (tag.selectedOperator) {
                    existingTag.selectedOperator = tag.selectedOperator;
                }

                tagify.replaceTag(existingTagElement, existingTag);

                // update the datasource params
                await onRangePickerChange(true, false);

                return;
            }
        } 

        /* Lookup by key, value and operator (do not add the same key and value multiple times) */
        let existingTagElement = existingTagElms.find(htmlTag => 
            htmlTag.getAttribute('key') === tag.key
            && htmlTag.getAttribute('realValue') === tag.realValue 
            //&& htmlTag.getAttribute('selectedOperator') === tag.selectedOperator
        );
        let existingTag = tagify.tagData(existingTagElement);
        if (existingTag !== undefined) {
            return;
        }

        // has the tag an operator object?
        if (DEFINED_TAGS[tag.key] && !Array.isArray(DEFINED_TAGS[tag.key])) {
            tag.operators = DEFINED_TAGS[tag.key].operators;
        }

        if (!tag.selectedOperator) {
            tag.selectedOperator = 'eq';
        }

        // add filter!
        tagify.addTags([tag]);
    }

    // on apply button click
    $(`.range-picker`).on('change', async function(e) {
        await onRangePickerChange(true, false);
    });

    $(`#select-len`).on('change', async function() {
        await onRangePickerChange(true, false);
    });

    // when an user remove the tag
    tagify.on('remove', async function(e) {
        const key = e.detail.data.key;

        if (key === undefined) {
            return;
        }

        if (datasourceParams[key] !== undefined) {
            delete datasourceParams[key];
        }

        await onRangePickerChange(true, false);

        // This is done because if no table is present in the page then 
        // the page is not reloaded when removing a tag
        {% if reload_when_removing then %}
            window.location.reload();
        {% end %}
    });

    tagify.on('add', async function(e) {

        const detail = e.detail;
        if (detail.data === undefined) { return; }

        const tag = detail.data;

        // let's check if the tag has a key field
        if (!tag.key) {
            tagify.removeTags([e.detail.tag]);
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // add/update datasource params, default operator `=`
        if (!tag.selectedOperator) tag.selectedOperator = 'eq';

        {% if query_presets ~= nil and query_presets ~= {} then %}
        // When adding tags in a query page switch to the flows page if the tag is not defined in the query filters
        if ($(`#select-query-presets`).val() != "" && !tag.operators /* No DEFINED_TAGS for this */)
            $(`#select-query-presets`).val("");
        {% end %}

        // trigger request
        await onRangePickerChange(true, false);
    });

    // Tag 'click' event handler to open the 'Edit' modal. Note: this prevents
    // inline editing of the tag ('edit:updated' is never called as a consequence)
    tagify.on('click', async function(e) {
        const detail = e.detail;

        if (detail.data === undefined) { return; }
        if (detail.data.key === undefined) {return;}

        const tag = detail.data;

        pageHandle.filterModalShow(true);

        $('#dt-add-filter-modal input[name="index"]').val(detail.index);
        $('#dt-filter-type-select').val(tag.key).change();

        let value = tag.realValue || tag.value;

        let value_select = $('#dt-add-filter-modal select[name="value"]');
        if (value_select) {
            value_select.val(value);
        }

        let value_input = $('#dt-add-filter-modal input[name="value"]');
        if (value_input) {
            value_input.val(value);
        }

        let operator_select = $('#dt-add-filter-modal select[name="operator"]');

        if (operator_select) {
            operator_select.val(tag.selectedOperator);
        }
    });

    tagify.on('edit:updated', async function(e) {
        const detail = e.detail;

        if (detail.data === undefined) { return; }
        if (detail.data.key === undefined) {return;}

        const tag = detail.data;
        const prevTag = detail.previousData;

        tag.realValue = tag.value;

        // trigger request
        await onRangePickerChange(true, false);
    });

    $(`tags`).on('change', 'select.operator', async function(e) {
        // update the tag and the operator
        const $tag = $(this).parents('tag');
        const tagData = tagify.tagData($tag[0]);
        const selectedOperator = $(this).val();

        $tag.attr("selectedoperator", selectedOperator);

        tagData.selectedOperator = selectedOperator;

        // trigger request
        await onRangePickerChange(true, false);
    });

    $(".btn-remove-tags").on('click', async function() {
        // clear all the filters on click

        const tags = tagify.getTagElms();
        for (const tag of tags) {
            const key = tag.getAttribute('key');
            if (datasourceParams[key]) {
                delete datasourceParams[key];
            }
        }

        tagify.removeAllTags();

        await onRangePickerChange(true, false);
    });

    const addFilter = (e, a, from_table) => {
        e.preventDefault();

        let key = undefined;
        let displayValue = undefined;
        let realValue = undefined;
        let operator = 'eq';

        if (from_table != undefined) {
            const colIndex = from_table.cell(a.parent()).index().column;

            // Read tag key from the column
            key = from_table.column(colIndex).name();

	        // Read tag key from the cell if any
            const data = from_table.cell(a.parent()).data();
            if (data.tag_key)
                key = data.tag_key;

	        // Read value from the cell
            displayValue = (data.label ? data.label : ((data.value != undefined) ? data.value : data));
            displayValue  = NtopUtils.stripTags(displayValue);
            realValue = ((data.value != undefined) ? data.value : data);
        }

        // Read tag key and value from the <a> itself if provided
        if (a.data('tagKey')        != undefined) key          = a.data('tagKey');
        if (a.data('tagLabel')      != undefined) displayValue = a.data('tagLabel');
        if (a.data('tagRealvalue')  != undefined) realValue    = a.data('tagRealvalue');
        else if (a.data('tagValue') != undefined) realValue    = a.data('tagValue');
        if (a.data('tagOperator')   != undefined) operator     = a.data('tagOperator');

        const tag = {
            label: i18n.tags[key],
            key: key,
            value: displayValue,
            realValue: realValue,
            title: realValue,
            selectedOperator: operator
        };

        addFilterTag(tag);
    }

    // when the user navigates using the browser's arrows
    // set the input boxes with their respective values
    $(window).on('popstate', function(e) {
        const {state} = e.originalEvent;
        /* Prevent js error with state === null */
        if(state) {
            const {epoch_begin, epoch_end} = state;    
            let begin = new Date(epoch_begin * 1000).toISOString().slice(0,16);
            let end = new Date(epoch_end * 1000).toISOString().slice(0,16);

            begin = begin.split('T');
            end = end.split('T');
            
            // update the datetimepickers and their maximum / minimum value
            $(`#end-date`).attr('min', begin[0]);
            $(`#begin-date`).attr('max', end[0]);

            $(`#begin-date`).attr('value', begin[0]);
            $(`#begin-time`).attr('value', begin[1]);
            
            $(`#end-date`).attr('value', end[0]);
            $(`#end-time`).attr('value', end[1]);
        }
    });

    /*** Filters modal ***/

    // load data for filters (e.g. alert types in the selected range)
    async function filterModalLoadData() {
        const [begin, end] = getTimestampRange();
        /* Here it is where we can load dynamic data on time range change */
    }

    pageHandle.filterModalShow = function(edit) {
        $('#dt-add-filter-modal-title').text(edit ? "{{i18n('datatable.edit_filter')}}" : "{{i18n('datatable.add_filter')}}");
        $('#dt-add-filter-btn').text(edit ? "{{i18n('apply')}}" : "{{i18n('add')}}");
        $('#dt-filter-type-select').prop( "disabled", edit ? true : false);
        $('#dt-add-filter-modal').modal('show');
        $('#dt-add-filter-modal input[name="index"]').val('');
    }

    const filterModalMakeTag = (formSelector) => {
       const filter_type = $(`${formSelector} [name='filter_type']`).val();

       let tag = {
           key: filter_type,             // e.g. l7_proto 
           label: i18n.tags[filter_type] // e.g. L7 Proto
       }

       let index = $(`${formSelector} input[name='index']`).val();
       if (index) {
           tag.index = index;
       }

       // load filter params inside the template container
       const $inputsTemplate = $(`${formSelector} .dt-filter-template-container [name]`);
       $inputsTemplate.each(function (i, input) {
           if ($(this).attr('name') == 'operator') {
               tag.selectedOperator = $(this).val().trim();
           } else {
               tag.realValue = $(this).val().trim();
               tag.value = $('option:selected', this).data('tagLabel');
               if (!tag.value) tag.value = tag.realValue;
           }
       });

       return tag;
       }

       function filterModalCloneTemplate(type) {
       const template = $(`template#${type}-filter-template`).html();
       // if the template is not empty then return a copy of the template content
       if (template && template.trim() != "") {
           const $template = $(template);
           return $template;
       }
       return (null);
       }

       function filterModalSetContent(container, content) {
       // show the template inside the modal container
       container.hide().empty();

       if (content) {
           container.append($(`<hr>`));
           container.append(content).show();
       }
       }

       const filterModalCreateTemplateOnSelect = (formSelector) => {

       const $templateContainer = $(`${formSelector} .dt-filter-template-container`);

       // on filter type Selection load the right template to fill
       $(`${formSelector} select[name='filter_type']`).change(function (e) {
           const $option = $(this).find(`option[value='${$(this).val()}']`);
           const $cloned = filterModalCloneTemplate($option.data('filterKey'));
           filterModalSetContent($templateContainer, $cloned);
           $(`${formSelector} span.test-feedback`).fadeOut();
       });
       }

    /* bind add filter event */
    $(`#dt-add-filter-modal form`).modalHandler({
        /* Note: no endpoint defined, ajax is not used here */
        resetAfterSubmit: false,
        onModalInit: () => { filterModalCreateTemplateOnSelect(`#dt-add-filter-modal`); },
        onModalShow: () => {
            const $templateContainer = $(`#dt-add-filter-modal form .dt-filter-template-container`);
            // load the template of the selected filter
            const $cloned = filterModalCloneTemplate($(`#dt-add-filter-modal select[name='filter_type'] option:selected`).data('filterKey'));
            filterModalSetContent($templateContainer, $cloned);
        },
        beforeSumbit: () => {
            $(`#dt-add-filter-modal form button[type='submit']`).click(function () {
                $(`#dt-add-filter-modal form span.invalid-feedback`).hide();
            });

            $(`#dt-add-filter-modal .test-feedback`).hide();

            const tag = filterModalMakeTag(`#dt-add-filter-modal form`);

            addFilterTag(tag);

            return {};
        },
        onSubmitSuccess: (response) => {
            // hide modal
            $(`#dt-add-filter-modal`).modal('hide');
            $(`#dt-add-filter-modal form .dt-filter-template-container`).hide();
            return true;
        }
    }).invokeModalInit();

</script>
